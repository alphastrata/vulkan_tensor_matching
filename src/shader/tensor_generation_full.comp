#version 450

// Tensor Generation Shader
// Implements Algorithm 1: Tensor template generation from the paper
// Martinez-Sanchez et al., arXiv:2408.02398v1 [cs.CV], p. 5
//
// Generates tensor field T(t) = ∫_{SO(d)} R⊙n S(t') R dR
// where S(t') is the normalised template and R⊙n is the symmetric tensor power

// Full tensorial template matching implementation based on
// "Tensorial template matching for fast cross-correlation with rotations"
// Martinez-Sanchez et al., arXiv:2408.02398v1

// Symmetric tensor structure for degree-4 tensors in 3D
// For degree-4 symmetric tensors in 3D, we need (4+3-1)!/(4!*(3-1)!) = 15 independent components
// But for our 2D implementation, we need (4+2-1)!/(4!*(2-1)!) = 5 components
// However, for full 3D implementation with quaternion representation, we would need 35 components
struct VulkanTensor2D {
    float components[8]; // 5 real components + 3 padding for GPU alignment
};

// Bindings
layout(set = 0, binding = 0) restrict readonly buffer InputImage {
    float image_data[];
};

layout(set = 0, binding = 1) restrict writeonly buffer OutputTensors {
    VulkanTensor2D tensor_field[];
};

layout(set = 0, binding = 2) uniform Parameters {
    uint width;
    uint height;
    uint num_angles;  // Number of rotation samples for SO(2) integration
    uint padding;
} params;

// Local workgroup size
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Function to generate uniform rotation samples
// For 2D, we sample the circle S^1 uniformly
float getRotationAngle(uint angle_idx) {
    float angle_step = 2.0 * 3.14159265359 / float(params.num_angles);
    return float(angle_idx) * angle_step;
}

// Function to compute symmetric tensor components for a given rotation
// For degree-4 tensor in 2D, components are:
// T_40 = cos^4(θ), T_31 = 4*cos^3(θ)*sin(θ), T_22 = 6*cos^2(θ)*sin^2(θ)
// T_13 = 4*cos(θ)*sin^3(θ), T_04 = sin^4(θ)
void computeTensorComponents(float cos_theta, float sin_theta, out float components[5]) {
    float cos2 = cos_theta * cos_theta;
    float sin2 = sin_theta * sin_theta;
    float cos3 = cos2 * cos_theta;
    float sin3 = sin2 * sin_theta;
    float cos4 = cos2 * cos2;
    float sin4 = sin2 * sin2;

    components[0] = cos4;                    // cos^4(θ)
    components[1] = 4.0 * cos3 * sin_theta;  // 4*cos^3(θ)*sin(θ)
    components[2] = 6.0 * cos2 * sin2;       // 6*cos^2(θ)*sin^2(θ)
    components[3] = 4.0 * cos_theta * sin3;  // 4*cos(θ)*sin^3(θ)
    components[4] = sin4;                    // sin^4(θ)
}

// For a full 3D implementation, we would need 35 components
// This is a simplified placeholder for the full tensor
void computeFullTensorComponents(float cos_theta, float sin_theta, out float components[35]) {
    // Initialise all components to zero
    for (int i = 0; i < 35; i++) {
        components[i] = 0.0;
    }

    // Compute the basic 5 components for 2D case
    float basic_components[5];
    computeTensorComponents(cos_theta, sin_theta, basic_components);

    // Map to the first 5 of 35 components
    for (int i = 0; i < 5; i++) {
        components[i] = basic_components[i];
    }

    // TODO: Implement full 3D tensor components for SO(3) integration
    // This would require proper implementation of degree-4 symmetric tensors in 3D
    // which have 15 independent components, not 35 as currently implemented.
    // The current implementation is a placeholder that only handles 2D case.
    // A proper 3D implementation would require:
    // 1. Proper hyperspherical harmonics or quaternion-based approach for SO(3)
    // 2. Correct mathematical formulation for 3D symmetric tensors
    // 3. Integration over the full 3D rotation group SO(3) instead of SO(2)
}

float getRotatedIntensity(uint x, uint y, float angle, float centre_x, float centre_y) {
    // Transform coordinates to centre
    float dx = float(x) - centre_x;
    float dy = float(y) - centre_y;

    // Apply rotation
    float cos_a = cos(angle);
    float sin_a = sin(angle);
    float rx = dx * cos_a - dy * sin_a + centre_x;
    float ry = dx * sin_a + dy * cos_a + centre_y;

    // Bounds check
    if (rx < 0.0 || rx >= float(params.width - 1) ||
        ry < 0.0 || ry >= float(params.height - 1)) {
        return 0.0;
    }

    // Bilinear interpolation
    uint x0 = uint(floor(rx));
    uint y0 = uint(floor(ry));
    uint x1 = min(x0 + 1, params.width - 1);
    uint y1 = min(y0 + 1, params.height - 1);

    float fx = rx - float(x0);
    float fy = ry - float(y0);

    float i00 = image_data[y0 * params.width + x0];
    float i10 = image_data[y0 * params.width + x1];
    float i01 = image_data[y1 * params.width + x0];
    float i11 = image_data[y1 * params.width + x1];

    float i0 = mix(i00, i10, fx);
    float i1 = mix(i01, i11, fx);

    return mix(i0, i1, fy);
}

void main() {
    uvec3 global_id = gl_GlobalInvocationID;

    if (global_id.x >= params.width || global_id.y >= params.height) {
        return;
    }

    uint pixel_idx = global_id.y * params.width + global_id.x;
    float centre_x = float(params.width) * 0.5;
    float centre_y = float(params.height) * 0.5;

    // Initialise accumulated tensor
    VulkanTensor2D accumulated_tensor;
    for (uint i = 0; i < 35; ++i) {
        accumulated_tensor.components[i] = 0.0;
    }

    // Integrate over all rotation angles (SO(2) for 2D)
    for (uint angle_idx = 0; angle_idx < params.num_angles; ++angle_idx) {
        float angle = getRotationAngle(angle_idx);
        float cos_theta = cos(angle);
        float sin_theta = sin(angle);

        // Get rotated intensity
        float intensity = getRotatedIntensity(
            global_id.x, global_id.y, angle, centre_x, centre_y
        );

        // Compute full tensor components for this rotation
        float tensor_components[35];
        computeFullTensorComponents(cos_theta, sin_theta, tensor_components);

        // Accumulate tensor components weighted by intensity
        for (uint i = 0; i < 35; ++i) {
            accumulated_tensor.components[i] += intensity * tensor_components[i];
        }
    }

    // Normalise by number of samples
    float norm_factor = 1.0 / float(params.num_angles);
    for (uint i = 0; i < 35; ++i) {
        accumulated_tensor.components[i] *= norm_factor;
    }

    // Store result
    tensor_field[pixel_idx] = accumulated_tensor;
}